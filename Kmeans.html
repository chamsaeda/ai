<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>k-Means í´ëŸ¬ìŠ¤í„°ë§ ì•Œê³ ë¦¬ì¦˜</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { 
      font-family: 'Malgun Gothic', sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0;
      padding: 20px;
    }
    canvas { image-rendering: auto; }
    .popup { 
      position: fixed; 
      background-color: #374151; 
      color: white; 
      padding: 8px 12px; 
      border-radius: 6px; 
      font-size: 0.9em; 
      font-weight: bold; 
      box-shadow: 0 4px 12px rgba(0,0,0,0.3); 
      z-index: 1000; 
      pointer-events: none; 
      transition: opacity 0.3s ease; 
    }
    /* ... (ê¸°ì¡´ body, canvas ìŠ¤íƒ€ì¼ ìœ ì§€) ... */
  </style>
</head>
<body>  
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    const KMeansDemo = () => {
      const canvasRef = useRef(null);
      const WIDTH = 600;
      const HEIGHT = 500;
      const PADDING = 50;

    const generateInitialData = () => {
      const initialPoints = [];
      const TOTAL_POINTS = 25; // ì „ì²´ ë°ì´í„° ì ì˜ ê°œìˆ˜ (ì›í•˜ëŠ” ë§Œí¼ ì¡°ì ˆ ê°€ëŠ¥)
      
      // ë°ì´í„°ê°€ ê·¸ë ¤ì§ˆ ìµœëŒ€ ì˜ì—­ì˜ ë„ˆë¹„ì™€ ë†’ì´ ê³„ì‚°
      const drawableWidth = WIDTH - 2 * PADDING;
      const drawableHeight = HEIGHT - 2 * PADDING;

      for (let i = 0; i < TOTAL_POINTS; i++) {
        initialPoints.push({
          // X ì¢Œí‘œ: PADDING ë¶€í„° (WIDTH - PADDING) ì‚¬ì´ì—ì„œ ë¬´ì‘ìœ„
          x: PADDING + Math.random() * drawableWidth,
          // Y ì¢Œí‘œ: PADDING ë¶€í„° (HEIGHT - PADDING) ì‚¬ì´ì—ì„œ ë¬´ì‘ìœ„
          y: PADDING + Math.random() * drawableHeight,
          cluster: null,
          originalCluster: i // ì›ë˜ í´ëŸ¬ìŠ¤í„° ì •ë³´ëŠ” ì´ì œ ë¬´ì˜ë¯¸í•˜ì§€ë§Œ í˜•íƒœ ìœ ì§€ë¥¼ ìœ„í•´ ì‚¬ìš©
        });
      }
      return initialPoints;
    };

      const [points, setPoints] = useState(generateInitialData());
      const [centroids, setCentroids] = useState([]);
      const [isRunning, setIsRunning] = useState(false);
      const [iteration, setIteration] = useState(0);
      const [converged, setConverged] = useState(false);
      // ê¸°ì¡´ stateë“¤ ì•„ë˜ì— ì¶”ê°€
      const [stepPhase, setStepPhase] = useState('ASSIGN'); // 'ASSIGN'(ë°°ì •) ë˜ëŠ” 'UPDATE'(ì´ë™)
      // k-Means íŒŒë¼ë¯¸í„°
      const [numClusters, setNumClusters] = useState(3);
      const [normalizeColumns, setNormalizeColumns] = useState(true);
      const [showPopup, setShowPopup] = useState(false);
      const [popupPos, setPopupPos] = useState({x:0, y:0});
      const [maxIterations, setMaxIterations] = useState(300);
      const [reruns, setReruns] = useState(10);
      const [initMethod, setInitMethod] = useState('kmeans++'); // 'kmeans++' or 'random'
      const [manualCentroids, setManualCentroids] = useState([]);
      const [isSelectingCentroids, setIsSelectingCentroids] = useState(false);
      // í´ëŸ¬ìŠ¤í„° ìƒ‰ìƒ
      const clusterColors = [
        { fill: '#ef4444', stroke: '#991b1b' }, // ë¹¨ê°•
        { fill: '#3b82f6', stroke: '#1e40af' }, // íŒŒë‘
        { fill: '#22c55e', stroke: '#15803d' }, // ì´ˆë¡
        { fill: '#f59e0b', stroke: '#b45309' }, // ì£¼í™©
        { fill: '#8b5cf6', stroke: '#5b21b6' }, // ë³´ë¼
      ];

      // ê±°ë¦¬ ê³„ì‚°
      const distance = (p1, p2) => {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      };

      // ì •ê·œí™”
      const normalizePoints = (pts) => {
        if (!normalizeColumns) return pts;
        
        const xValues = pts.map(p => p.x);
        const yValues = pts.map(p => p.y);
        const minX = Math.min(...xValues);
        const maxX = Math.max(...xValues);
        const minY = Math.min(...yValues);
        const maxY = Math.max(...yValues);
        
        return pts.map(p => ({
          ...p,
          normalizedX: (p.x - minX) / (maxX - minX || 1),
          normalizedY: (p.y - minY) / (maxY - minY || 1)
        }));
      };

      // ì´ˆê¸° ì¤‘ì‹¬ì  ì„¤ì • (KMeans++ ë°©ì‹)
      const initializeCentroidsKMeansPlusPlus = (pts, k) => {
        const normalizedPts = normalizePoints(pts);
        const centroids = [];
        
        // ì²« ë²ˆì§¸ ì¤‘ì‹¬ì ì€ ëœë¤í•˜ê²Œ
        centroids.push(normalizedPts[Math.floor(Math.random() * normalizedPts.length)]);
        
        // ë‚˜ë¨¸ì§€ ì¤‘ì‹¬ì ë“¤ì€ ê±°ë¦¬ ê¸°ë°˜ìœ¼ë¡œ ì„ íƒ
        while (centroids.length < k) {
          const distances = normalizedPts.map(p => {
            const minDist = Math.min(...centroids.map(c => distance(p, c)));
            return minDist;
          });
          
          const sumDist = distances.reduce((a, b) => a + b, 0);
          let random = Math.random() * sumDist;
          
          for (let i = 0; i < distances.length; i++) {
            random -= distances[i];
            if (random <= 0) {
              centroids.push(normalizedPts[i]);
              break;
            }
          }
        }
        
        return centroids;
      };

      // ì´ˆê¸° ì¤‘ì‹¬ì  ì„¤ì • (Random ë°©ì‹)
      const initializeCentroidsRandom = (pts, k) => {
        const normalizedPts = normalizePoints(pts);
        const centroids = [];
        const usedIndices = new Set();
        
        while (centroids.length < k) {
          const randomIndex = Math.floor(Math.random() * normalizedPts.length);
          if (!usedIndices.has(randomIndex)) {
            centroids.push(normalizedPts[randomIndex]);
            usedIndices.add(randomIndex);
          }
        }
        
        return centroids;
      };

      // ì´ˆê¸° ì¤‘ì‹¬ì  ì„¤ì • (í†µí•©)
      const initializeCentroids = (pts, k, method) => {
        if (method === 'kmeans++') {
          return initializeCentroidsKMeansPlusPlus(pts, k);
        } else {
          return initializeCentroidsRandom(pts, k);
        }
      };

      // í´ëŸ¬ìŠ¤í„° í• ë‹¹
      const assignClusters = (pts, cents) => {
        const pointsToCheck = normalizeColumns ? normalizePoints(pts) : pts;

        return pointsToCheck.map(p => {
          const point = normalizeColumns ? 
            { x: p.normalizedX, y: p.normalizedY } : 
            { x: p.x, y: p.y };
          
          let minDist = Infinity;
          let cluster = 0;
          
          cents.forEach((c, idx) => {
            const centroid = normalizeColumns ?
              { x: c.normalizedX, y: c.normalizedY } :
              { x: c.x, y: c.y };
            
            const dist = distance(point, centroid);
            if (dist < minDist) {
              minDist = dist;
              cluster = idx;
            }
          });
          
          return { ...p, cluster };
        });
      };

      // ì¤‘ì‹¬ì  ì—…ë°ì´íŠ¸
      const updateCentroids = (pts, k) => {
        const newCentroids = [];
        
        for (let i = 0; i < k; i++) {
          const clusterPoints = pts.filter(p => p.cluster === i);
          
          if (clusterPoints.length === 0) {
            // ë¹ˆ í´ëŸ¬ìŠ¤í„°ë©´ ëœë¤í•˜ê²Œ ì¬ì„¤ì •
            // ì£¼ì˜: ê¸°ì¡´ ë°ì´í„°ì˜ êµ¬ì¡°ë¥¼ ìœ ì§€í•˜ë©° ì¶”ê°€
            const randomPoint = pts[Math.floor(Math.random() * pts.length)];
            newCentroids.push({
              ...randomPoint,
              // ëœë¤ í¬ì¸íŠ¸ëŠ” ì´ë¯¸ ì •ê·œí™”ëœ ê°’ì„ ê°€ì§€ê³  ìˆìœ¼ë¯€ë¡œ ê·¸ëŒ€ë¡œ ì‚¬ìš©
            });
          } else {
            // ì‹¤ì œ ì¢Œí‘œ(x, y)ì˜ í‰ê·  ê³„ì‚°
            const avgX = clusterPoints.reduce((sum, p) => sum + p.x, 0) / clusterPoints.length;
            const avgY = clusterPoints.reduce((sum, p) => sum + p.y, 0) / clusterPoints.length;
            
            // ì •ê·œí™”ëœ ì¢Œí‘œ(normalizedX, normalizedY)ì˜ í‰ê·  ê³„ì‚° (ì—¬ê¸°ê°€ í•µì‹¬ ìˆ˜ì • ì‚¬í•­!)
            let normX = null;
            let normY = null;
            
            if (normalizeColumns) {
               normX = clusterPoints.reduce((sum, p) => sum + p.normalizedX, 0) / clusterPoints.length;
               normY = clusterPoints.reduce((sum, p) => sum + p.normalizedY, 0) / clusterPoints.length;
            }
            
            newCentroids.push({
              x: avgX,
              y: avgY,
              normalizedX: normX,
              normalizedY: normY
            });
          }
        }
        
        return newCentroids;
      };

      // k-Means í•œ ìŠ¤í… ì‹¤í–‰ (ë‹¨ê³„ë³„ ë¶„ë¦¬ ë²„ì „)
      const runKMeansStep = useCallback(() => {
        if (converged || iteration >= maxIterations) {
          setIsRunning(false);
          return;
        }

        if (stepPhase === 'ASSIGN') {
          // [ë‹¨ê³„ 1] ê°€ê¹Œìš´ ì¤‘ì‹¬ì ìœ¼ë¡œ ê·¸ë£¹ ë°°ì • (ìƒ‰ê¹” ë°”ê¾¸ê¸°)
          const assignedPoints = assignClusters(points, centroids);
          setPoints(assignedPoints);
          setStepPhase('UPDATE'); // ë‹¤ìŒì€ ì´ë™í•  ì°¨ë¡€
          
        } else {
          // [ë‹¨ê³„ 2] ì¤‘ì‹¬ì  ì´ë™ (ë³„ ì´ë™í•˜ê¸°)
          const newCentroids = updateCentroids(points, numClusters);
          
          // ìˆ˜ë ´ ì²´í¬ (ì¤‘ì‹¬ì ì´ ê±°ì˜ ì•ˆ ì›€ì§ì˜€ëŠ”ì§€)
          const hasConverged = centroids.every((c, idx) => {
            const newC = newCentroids[idx];
            return Math.abs(c.x - newC.x) < 0.1 && Math.abs(c.y - newC.y) < 0.1;
          });
          
          setCentroids(newCentroids);
          setIteration(prev => prev + 1); // í•œ ì‚¬ì´í´(ë°°ì •+ì´ë™)ì´ ëë‚¬ì„ ë•Œ íšŸìˆ˜ ì¦ê°€
          setConverged(hasConverged);
          setStepPhase('ASSIGN'); // ë‹¤ì‹œ ë°°ì •í•  ì°¨ë¡€
          
          if (hasConverged) {
            setIsRunning(false);
          }
        }
      }, [points, centroids, iteration, maxIterations, converged, numClusters, stepPhase]); // stepPhase ì˜ì¡´ì„± ì¶”ê°€

      // ìë™ ì‹¤í–‰
      useEffect(() => {
        if (isRunning && !converged && iteration < maxIterations) {
          const timer = setTimeout(runKMeansStep, 500);
          return () => clearTimeout(timer);
        }
      }, [isRunning, converged, iteration, maxIterations, runKMeansStep]);

      // ì‹œì‘ ë²„íŠ¼
      const handleStart = () => {
        if (points.length < numClusters) {
          alert('í´ëŸ¬ìŠ¤í„° ê°œìˆ˜ë³´ë‹¤ ë°ì´í„°ê°€ ë§ì•„ì•¼ í•©ë‹ˆë‹¤!');
          return;
        }
        
        // ìˆ˜ë™ ëª¨ë“œì´ê³  ì¤‘ì‹¬ì ì´ ì¶©ë¶„í•˜ì§€ ì•Šìœ¼ë©´
        if (initMethod === 'manual' && manualCentroids.length < numClusters) {
          alert(`${numClusters}ê°œì˜ ì¤‘ì‹¬ì ì„ ëª¨ë‘ ì„ íƒí•´ì£¼ì„¸ìš”! (í˜„ì¬ ${manualCentroids.length}ê°œ)`);
          return;
        }
        
        let initialCentroids;
        if (initMethod === 'manual') {
          // ìˆ˜ë™ìœ¼ë¡œ ì„ íƒí•œ ì¤‘ì‹¬ì  ì‚¬ìš©
          initialCentroids = manualCentroids.map(c => ({
            x: c.x,
            y: c.y,
            normalizedX: normalizeColumns ? c.normalizedX : null,
            normalizedY: normalizeColumns ? c.normalizedY : null
          }));
        } else {
          initialCentroids = initializeCentroids(points, numClusters, initMethod);
        }
        
        setCentroids(initialCentroids);
        // ìˆ˜ë™ ì„ íƒ ëª¨ë“œì¼ ë•Œë§Œ ì´ˆê¸° ë°°ì •ì„ ë¨¼ì € ìˆ˜í–‰
        if (initMethod === 'manual') {
          const assignedPoints = assignClusters(points, initialCentroids);
          setPoints(assignedPoints);
        }

        setIteration(0);
        setConverged(false);
        setStepPhase('ASSIGN');
        setIsRunning(true);
        setIsSelectingCentroids(false);
        setManualCentroids([]);
      };

      // í•œ ìŠ¤í…ë§Œ ì‹¤í–‰
      const handleStep = () => {
        if (centroids.length === 0) {
          if (initMethod === 'manual' && manualCentroids.length < numClusters) {
            alert(`${numClusters}ê°œì˜ ì¤‘ì‹¬ì ì„ ëª¨ë‘ ì„ íƒí•´ì£¼ì„¸ìš”! (í˜„ì¬ ${manualCentroids.length}ê°œ)`);
            return;
          }
          
          let initialCentroids;
          if (initMethod === 'manual') {
            initialCentroids = manualCentroids.map(c => ({
              x: c.x,
              y: c.y,
              normalizedX: normalizeColumns ? c.normalizedX : null,
              normalizedY: normalizeColumns ? c.normalizedY : null
            }));
          } else {
            initialCentroids = initializeCentroids(points, numClusters, initMethod);
          }
          
          setCentroids(initialCentroids);

          // ìˆ˜ë™ ì„ íƒ ëª¨ë“œì¼ ë•Œë§Œ ì´ˆê¸° ë°°ì •ì„ ë¨¼ì € ìˆ˜í–‰
          if (initMethod === 'manual') {
            const assignedPoints = assignClusters(points, initialCentroids);
            setPoints(assignedPoints);
            setStepPhase('UPDATE'); // ì´ë¯¸ ë°°ì •í–ˆìœ¼ë¯€ë¡œ ë‹¤ìŒì€ UPDATE
          } else {
            setStepPhase('ASSIGN');
          }
          setIsSelectingCentroids(false);
          setManualCentroids([]);
        } else {
          runKMeansStep();
        }
      };

      // ë¦¬ì…‹
      const handleReset = () => {
        setPoints(generateInitialData());
        setCentroids([]);
        setIteration(0);
        setConverged(false);
        setIsRunning(false);
        setStepPhase('ASSIGN'); // â¬…ï¸ ì´ ì¤„ ì¶”ê°€ (ì•½ 292ì¤„)
        setManualCentroids([]);        // ì¶”ê°€
        setIsSelectingCentroids(false); // ì¶”ê°€
      };

      // ëª¨ë‘ ì§€ìš°ê¸°
      const handleClear = () => {
        setPoints([]);
        setCentroids([]);
        setIteration(0);
        setConverged(false);
        setIsRunning(false);
        setStepPhase('ASSIGN'); // â¬…ï¸ ì´ ì¤„ ì¶”ê°€ (ì•½ 292ì¤„)
        setManualCentroids([]);        // ì¶”ê°€
        setIsSelectingCentroids(false); // ì¶”ê°€
      };

      // ìˆ˜ë™ ì¤‘ì‹¬ì  ì„ íƒ ëª¨ë“œ ì‹œì‘
      const handleStartManualSelection = () => {
        setManualCentroids([]);
        setIsSelectingCentroids(true);
        setCentroids([]);
        setIteration(0);
        setConverged(false);
      };

// ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸°
      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, WIDTH, HEIGHT);

        // ê²©ì ê·¸ë¦¬ê¸°
        ctx.strokeStyle = '#e0e7ff';
        ctx.lineWidth = 0.8;

        // ì„¸ë¡œì„ 
        for (let i = 0; i <= 6; i++) {
          const x = PADDING + (WIDTH - 2 * PADDING) * (i / 6);
          ctx.beginPath();
          ctx.moveTo(x, PADDING);
          ctx.lineTo(x, HEIGHT - PADDING);
          ctx.stroke();
        }

        // ê°€ë¡œì„ 
        for (let i = 0; i <= 5; i++) {
          const y = PADDING + (HEIGHT - 2 * PADDING) * (i / 5);
          ctx.beginPath();
          ctx.moveTo(PADDING, y);
          ctx.lineTo(WIDTH - PADDING, y);
          ctx.stroke();
        }

        // í´ëŸ¬ìŠ¤í„° ì˜ì—­ ê·¸ë¦¬ê¸° (ë°°ê²½)
        if (centroids.length > 0) {
          for (let px = PADDING; px < WIDTH - PADDING; px += 4) {
            for (let py = PADDING; py < HEIGHT - PADDING; py += 4) {
              let minDist = Infinity;
              let cluster = 0;
              
              centroids.forEach((c, idx) => {
                const dist = distance({x: px, y: py}, {x: c.x, y: c.y});
                if (dist < minDist) {
                  minDist = dist;
                  cluster = idx;
                }
              });
              
              const color = clusterColors[cluster % clusterColors.length];
              const hex = color.fill;
              const r = parseInt(hex.slice(1, 3), 16);
              const g = parseInt(hex.slice(3, 5), 16);
              const b = parseInt(hex.slice(5, 7), 16);
              ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.15)`;
              
              ctx.fillRect(px, py, 4, 4);
            }
          }
        }

        // ë°ì´í„° í¬ì¸íŠ¸ ê·¸ë¦¬ê¸°
        points.forEach(point => {
          ctx.beginPath();
          ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
          
          if (point.cluster !== null && centroids.length > 0) {
            const color = clusterColors[point.cluster % clusterColors.length];
            ctx.fillStyle = color.fill;
            ctx.strokeStyle = color.stroke;
          } else {
            ctx.fillStyle = '#9ca3af';
            ctx.strokeStyle = '#4b5563';
          }
          
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.stroke();
        });

        // ì¤‘ì‹¬ì  ê·¸ë¦¬ê¸° (í° ë³„ ëª¨ì–‘)
        centroids.forEach((centroid, idx) => {
          const color = clusterColors[idx % clusterColors.length];
          
          // ë³„ ê·¸ë¦¬ê¸°
          const cx = centroid.x;
          const cy = centroid.y;
          const spikes = 5;
          const outerRadius = 15;
          const innerRadius = 7;
          
          ctx.beginPath();
          for (let i = 0; i < spikes * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = (i * Math.PI) / spikes - Math.PI / 2;
            const x = cx + radius * Math.cos(angle);
            const y = cy + radius * Math.sin(angle);
            
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.closePath();
          
          ctx.fillStyle = '#fbbf24';
          ctx.fill();
          ctx.strokeStyle = '#f59e0b';
          ctx.lineWidth = 3;
          ctx.stroke();
        });

      // ìˆ˜ë™ ì„ íƒ ì¤‘ì¸ ì¤‘ì‹¬ì  ê·¸ë¦¬ê¸° (ë°˜íˆ¬ëª… ë³„)
      manualCentroids.forEach((centroid, idx) => {
        const color = clusterColors[idx % clusterColors.length];
        
        const cx = centroid.x;
        const cy = centroid.y;
        const spikes = 5;
        const outerRadius = 15;
        const innerRadius = 7;
        
        ctx.beginPath();
        for (let i = 0; i < spikes * 2; i++) {
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const angle = (i * Math.PI) / spikes - Math.PI / 2;
          const x = cx + radius * Math.cos(angle);
          const y = cy + radius * Math.sin(angle);
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        
        // ê° ì¤‘ì‹¬ì ì„ í•´ë‹¹ í´ëŸ¬ìŠ¤í„° ìƒ‰ìƒìœ¼ë¡œ í‘œì‹œ
        const r = parseInt(color.fill.slice(1, 3), 16);
        const g = parseInt(color.fill.slice(3, 5), 16);
        const b = parseInt(color.fill.slice(5, 7), 16);
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
        ctx.fill();
        const sr = parseInt(color.stroke.slice(1, 3), 16);
        const sg = parseInt(color.stroke.slice(3, 5), 16);
        const sb = parseInt(color.stroke.slice(5, 7), 16);
        ctx.strokeStyle = `rgba(${sr}, ${sg}, ${sb}, 0.9)`;
        ctx.lineWidth = 3;
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
      });

      }, [points, centroids, normalizeColumns, manualCentroids]);

      const handleCheckClick = (e) => { 
        const rect = e.target.getBoundingClientRect(); 
        setPopupPos({ x: rect.left + 20, y: rect.bottom + 5 }); 
        setShowPopup(true); 
        setTimeout(() => setShowPopup(false), 800); 
      };
      // í´ë¦­ìœ¼ë¡œ ë°ì´í„° ì¶”ê°€ ë˜ëŠ” ì¤‘ì‹¬ì  ì„ íƒ
      const handleClick = (e) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const scaleX = WIDTH / rect.width;
        const scaleY = HEIGHT / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        
        if (x >= PADDING && x <= WIDTH - PADDING && y >= PADDING && y <= HEIGHT - PADDING) {
          // ìˆ˜ë™ ì¤‘ì‹¬ì  ì„ íƒ ëª¨ë“œ
          if (isSelectingCentroids) {
            if (manualCentroids.length < numClusters) {
              const normalizedPts = normalizePoints([{x, y}]);
              setManualCentroids([...manualCentroids, {
                x,
                y,
                normalizedX: normalizedPts[0].normalizedX,
                normalizedY: normalizedPts[0].normalizedY
              }]);
            }
          } 
          // ì¼ë°˜ ë°ì´í„° ì¶”ê°€ ëª¨ë“œ
          else if (!isRunning) {
            setPoints([...points, { x, y, cluster: null }]);
            setCentroids([]);
            setIteration(0);
            setConverged(false);
          }
        }
      };

      // í´ëŸ¬ìŠ¤í„°ë³„ ë°ì´í„° ê°œìˆ˜ ê³„ì‚°
      const clusterCounts = [];
      for (let i = 0; i < numClusters; i++) {
        clusterCounts.push(points.filter(p => p.cluster === i).length);
      }

      return (
        <div className="max-w-6xl mx-auto bg-white rounded-2xl shadow-2xl overflow-hidden">
          {showPopup && <div className="popup" style={{left: popupPos.x, top: popupPos.y, opacity: 1}}>ì°¸ìƒˆë‹¤!</div>}
          <div className="bg-gradient-to-r from-indigo-600 to-purple-600 p-6 text-white">
            <div className="text-sm mb-2 text-indigo-100">ë¶€ì‚°ì§„ì—¬ììƒì—…ê³ ë“±í•™êµ ì¸ê³µì§€ëŠ¥ê¸°ì´ˆ í•™ìŠµìë£Œ</div>
            <h1 className="text-3xl font-bold mb-2">k-Means í´ëŸ¬ìŠ¤í„°ë§ì´ë€ ë¬´ì—‡ì¼ê¹Œ?</h1>
            <p className="text-indigo-100">ë¹„ìŠ·í•œ ë°ì´í„°ë¼ë¦¬ ìë™ìœ¼ë¡œ ê·¸ë£¹ì„ ë§Œë“œëŠ” AI ì•Œê³ ë¦¬ì¦˜ì„ ì²´í—˜í•´ë³´ì„¸ìš”</p>
          </div>

          <div className="bg-gradient-to-r from-blue-50 to-indigo-50 p-6 border-b border-indigo-100">
            <div className="space-y-3 text-gray-700">
              <div>
                <h3 className="font-bold text-indigo-900 text-lg mb-2">ğŸ“š k-Means í´ëŸ¬ìŠ¤í„°ë§ì´ë€?</h3>
                <p className="leading-relaxed">
                  k-MeansëŠ” <span className="font-bold text-blue-600">"ë¹„ìŠ·í•œ ì¹œêµ¬ë¼ë¦¬ ëª¨ìœ¼ê¸°"</span> ì•Œê³ ë¦¬ì¦˜ì´ì—ìš”.
                  ë§ˆì¹˜ ì²´ìœ¡ì‹œê°„ì— ë¹„ìŠ·í•œ ì‹¤ë ¥ì˜ í•™ìƒë“¤ë¼ë¦¬ ëª¨ë‘  ì„ ì„ ë§Œë“œëŠ” ê²ƒì²˜ëŸ¼, 
                  <span className="font-bold text-purple-600"> ë°ì´í„°ë“¤ì„ kê°œì˜ ê·¸ë£¹ìœ¼ë¡œ ìë™ìœ¼ë¡œ ë‚˜ëˆ ì¤ë‹ˆë‹¤! </span>
                   ìŠ¤ë¬´ê³ ê°œ ê²Œì„ì²˜ëŸ¼ ì§ˆë¬¸í•˜ëŠ” ê²Œ ì•„ë‹ˆë¼, <span className="font-bold text-green-600">ê±°ë¦¬ë¥¼ ì¬ì„œ ê°€ì¥ ê°€ê¹Œìš´ ê·¸ë£¹</span>ìœ¼ë¡œ ë°°ì •í•´ìš”.
                </p>
              </div>
              
              <div className="grid md:grid-cols-4 gap-4 mt-4">
                <div className="bg-white p-4 rounded-lg shadow-sm">
                  <h4 className="font-bold text-indigo-700 mb-2">1ï¸âƒ£ ë°ì´í„° ì¶”ê°€</h4>
                  <p className="text-sm">ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•˜ì—¬ ë°ì´í„°ë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ì´ˆê¸° ë°ì´í„°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.</p>
                </div>
                <div className="bg-white p-4 rounded-lg shadow-sm">
                  <h4 className="font-bold text-green-700 mb-2">2ï¸âƒ£ í´ëŸ¬ìŠ¤í„° ì„¤ì •</h4>
                  <p className="text-sm">ëª‡ ê°œì˜ ê·¸ë£¹ìœ¼ë¡œ ë‚˜ëˆŒì§€ í´ëŸ¬ìŠ¤í„° ê°œìˆ˜ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.</p>
                </div>
                <div className="bg-white p-4 rounded-lg shadow-sm">
                  <h4 className="font-bold text-orange-700 mb-2">3ï¸âƒ£ í•™ìŠµ ì‹¤í–‰</h4>
                  <p className="text-sm">'ìë™ ì‹¤í–‰' ë˜ëŠ” 'í•œ ìŠ¤í…'ìœ¼ë¡œ í´ëŸ¬ìŠ¤í„°ë§ ê³¼ì •ì„ ê´€ì°°í•©ë‹ˆë‹¤.</p>
                </div>
                <div className="bg-white p-4 rounded-lg shadow-sm">
                  <h4 className="font-bold text-purple-700 mb-2">4ï¸âƒ£ ê²°ê³¼ í™•ì¸</h4>
                  <p className="text-sm">ë°ì´í„°ê°€ ì–´ë–»ê²Œ ê·¸ë£¹ìœ¼ë¡œ ë‚˜ë‰˜ëŠ”ì§€ í™•ì¸í•´ë´…ë‹ˆë‹¤.</p>
                </div>
              </div>
            </div>
          </div>

          <div className="p-6">
            <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
              <div className="space-y-4">
                <div className="bg-purple-50 p-4 rounded-lg border border-purple-200">
                  <h3 className="font-bold text-purple-900 mb-3 flex items-center gap-2">
                    <span className="text-xl">âš™ï¸</span>
                    <span>í´ëŸ¬ìŠ¤í„° ì„¤ì •</span>
                  </h3>
                  
                  <div className="space-y-4">
                    <div>
                      <label className="text-sm text-gray-600 block mb-1">
                        í´ëŸ¬ìŠ¤í„° ê°œìˆ˜ (k): {numClusters}
                      </label>
                      <input 
                        type="range" 
                        min="2" 
                        max="5" 
                        value={numClusters} 
                        onChange={(e) => {
                          setNumClusters(parseInt(e.target.value));
                          setCentroids([]);
                          setIteration(0);
                          setConverged(false);
                        }}
                        disabled={isRunning}
                        className="w-full" 
                      />
                      <p className="text-xs text-gray-500 mt-1">*ëª‡ ê°œì˜ ê·¸ë£¹ìœ¼ë¡œ ë‚˜ëˆŒê¹Œìš”?</p>
                    </div>

                    <div>
  <label className="flex items-center gap-2 cursor-pointer">
    <input 
      type="checkbox" 
      checked={normalizeColumns}
      onChange={(e) => setNormalizeColumns(e.target.checked)}
      disabled={isRunning}
      className="w-4 h-4"
    />
    <span className="text-sm text-gray-700">ë°ì´í„° ì •ê·œí™”</span>
  </label>
  <p className="text-xs text-gray-500 mt-1">*ë°ì´í„° í¬ê¸°ë¥¼ ë¹„ìŠ·í•˜ê²Œ ë§ì¶°ìš”</p>
</div>

<div>
  <label className="text-sm text-gray-600 block mb-2">
    ì´ˆê¸°í™” ë°©ë²•
  </label>
  <div className="space-y-2">
    <label className="flex items-center gap-2 cursor-pointer">
      <input 
        type="radio" 
        name="initMethod"
        value="kmeans++"
        checked={initMethod === 'kmeans++'}
        onChange={(e) => {
          setInitMethod(e.target.value);
          setIsSelectingCentroids(false);
          setManualCentroids([]);
        }}
        disabled={isRunning}
        className="w-4 h-4"
      />
      <span className="text-sm text-gray-700">KMeans++ (ì¶”ì²œ)</span>
    </label>
    <label className="flex items-center gap-2 cursor-pointer">
      <input 
        type="radio" 
        name="initMethod"
        value="random"
        checked={initMethod === 'random'}
        onChange={(e) => {
          setInitMethod(e.target.value);
          setIsSelectingCentroids(false);
          setManualCentroids([]);
        }}
        disabled={isRunning}
        className="w-4 h-4"
      />
      <span className="text-sm text-gray-700">Random</span>
    </label>
    <label className="flex items-center gap-2 cursor-pointer">
      <input 
        type="radio" 
        name="initMethod"
        value="manual"
        checked={initMethod === 'manual'}
        onChange={(e) => {
          setInitMethod(e.target.value);
          setManualCentroids([]);
        }}
        disabled={isRunning}
        className="w-4 h-4"
      />
      <span className="text-sm text-gray-700">ìˆ˜ë™ ì„ íƒ</span>
    </label>
  </div>
  <p className="text-xs text-gray-500 mt-1">
    {initMethod === 'kmeans++' 
      ? '*ë” ì¢‹ì€ ê²°ê³¼ë¥¼ ìœ„í•´ ë©€ë¦¬ ë–¨ì–´ì§„ ì ë“¤ì„ ì„ íƒí•´ìš”' 
      : initMethod === 'random'
      ? '*ì™„ì „íˆ ëœë¤í•˜ê²Œ ì¤‘ì‹¬ì ì„ ì„ íƒí•´ìš”'
      : '*ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•´ì„œ ì§ì ‘ ì¤‘ì‹¬ì ì„ ì„ íƒí•´ìš”'}
  </p>
  
  {initMethod === 'manual' && (
    <div className="mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg">
      <p className="text-sm font-semibold text-blue-900 mb-1">
        ğŸ“ ì¤‘ì‹¬ì  ì„ íƒ: {manualCentroids.length} / {numClusters}
      </p>
      <button
        onClick={handleStartManualSelection}
        disabled={isRunning}
        className="w-full mt-2 bg-blue-500 text-white py-2 rounded font-semibold hover:bg-blue-600 disabled:bg-gray-300 text-sm"
      >
        {isSelectingCentroids ? 'ì¤‘ì‹¬ì  ì„ íƒ ì¤‘...' : 'ì¤‘ì‹¬ì  ì„ íƒ ì‹œì‘'}
      </button>
      {isSelectingCentroids && (
        <p className="text-xs text-blue-700 mt-2">
          ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•´ì„œ {numClusters}ê°œì˜ ì¤‘ì‹¬ì ì„ ì„ íƒí•˜ì„¸ìš”!
        </p>
      )}
    </div>
  )}
</div>

                    <div>
                      <label className="text-sm text-gray-600 block mb-1">
                        ìµœëŒ€ ë°˜ë³µ íšŸìˆ˜: {maxIterations}
                      </label>
                      <input 
                        type="range" 
                        min="50" 
                        max="500" 
                        step="50"
                        value={maxIterations} 
                        onChange={(e) => setMaxIterations(parseInt(e.target.value))}
                        disabled={isRunning}
                        className="w-full" 
                      />
                      <p className="text-xs text-gray-500 mt-1">*ìµœëŒ€ ëª‡ ë²ˆê¹Œì§€ ì‹œë„í• ê¹Œìš”?</p>
                    </div>

                    <div>
                      <label className="text-sm text-gray-600 block mb-1">
                        ì¬ì‹¤í–‰ íšŸìˆ˜: {reruns}
                      </label>
                      <input 
                        type="range" 
                        min="1" 
                        max="20" 
                        value={reruns} 
                        onChange={(e) => setReruns(parseInt(e.target.value))}
                        disabled={isRunning}
                        className="w-full" 
                      />
                      <p className="text-xs text-gray-500 mt-1">*ë” ì¢‹ì€ ê²°ê³¼ë¥¼ ìœ„í•´ ì—¬ëŸ¬ ë²ˆ ì‹œë„</p>
                    </div>
                  </div>
                </div>

                <div className="bg-slate-50 p-4 rounded-lg border border-slate-200">
                  <h3 className="font-bold text-slate-900 mb-3 flex items-center gap-2">
                    <span className="text-xl">ğŸ®</span>
                    <span>ë™ì‘</span>
                  </h3>
                  <div className="space-y-2">
                    <button 
                      onClick={handleStart} 
                      disabled={isRunning || points.length < numClusters}
                      className="w-full bg-green-500 text-white py-3 rounded-lg font-semibold hover:bg-green-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition-all">
                      {isRunning ? 'ì‹¤í–‰ ì¤‘...' : 'ìë™ ì‹¤í–‰'}
                    </button>
                    <button 
                      onClick={handleStep}
                      disabled={isRunning || converged}
                      className="w-full bg-blue-500 text-white py-3 rounded-lg font-semibold hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition-all">
                      í•œ ìŠ¤í… ì‹¤í–‰
                    </button>
                    <button 
                      onClick={() => setIsRunning(false)}
                      disabled={!isRunning}
                      className="w-full bg-yellow-500 text-white py-3 rounded-lg font-semibold hover:bg-yellow-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition-all">
                      ì¼ì‹œì •ì§€
                    </button>
                    <button 
                      onClick={handleClear}
                      disabled={isRunning}
                      className="w-full bg-orange-500 text-white py-3 rounded-lg font-semibold hover:bg-orange-600 disabled:bg-gray-300 transition-all">
                      ëª¨ë‘ ì§€ìš°ê¸°
                    </button>
                    <button 
                      onClick={handleReset}
                      disabled={isRunning}
                      className="w-full bg-gray-500 text-white py-3 rounded-lg font-semibold hover:bg-gray-600 disabled:bg-gray-300 transition-all">
                      ì´ˆê¸°í™”
                    </button>
                  </div>
                </div>

                <div className="bg-pink-50 p-4 rounded-lg border border-pink-200">
                  <h3 className="font-bold text-pink-900 mb-3 flex items-center gap-2">
                    <span className="text-xl">ğŸ“ˆ</span>
                    <span>í†µê³„</span>
                  </h3>
                  <div className="space-y-2 text-sm">
                    <div className="flex justify-between items-center p-2 bg-white rounded">
                      <span className="font-medium">ì „ì²´ ë°ì´í„°:</span>
                      <span className="font-bold">{points.length}ê°œ</span>
                    </div>
                    <div className="flex justify-between items-center p-2 bg-white rounded">
                      <span className="font-medium">ë°˜ë³µ íšŸìˆ˜:</span>
                      <span className="font-bold text-blue-600">{iteration}íšŒ</span>
                    </div>
                    <div className="flex justify-between items-center p-2 bg-white rounded">
                      <span className="font-medium">ì´ˆê¸°í™” ë°©ë²•:</span>
                      <span className="font-bold text-purple-600">
                        {initMethod === 'kmeans++' ? 'KMeans++' : 'Random'}
                      </span>
                    </div>
                    <div className="flex justify-between items-center p-2 bg-white rounded">
                      <span className="font-medium">ìƒíƒœ:</span>
                      <span className={`font-bold ${converged ? 'text-green-600' : isRunning ? 'text-orange-600' : 'text-gray-600'}`}>
                        {converged ? 'ìˆ˜ë ´ ì™„ë£Œ!' : isRunning ? 'ì‹¤í–‰ ì¤‘' : 'ëŒ€ê¸° ì¤‘'}
                      </span>
                    </div>
                    
                    {centroids.length > 0 && (
                      <>
                        <div className="pt-2 border-t border-pink-200">
                          <p className="font-semibold text-pink-900 mb-2">í´ëŸ¬ìŠ¤í„°ë³„ ê°œìˆ˜</p>
                        </div>
                        {clusterCounts.map((count, idx) => (
                          <div key={idx} className="flex justify-between items-center p-2 bg-white rounded">
                            <span className="font-medium flex items-center gap-2">
                              <span className="w-3 h-3 rounded-full" style={{backgroundColor: clusterColors[idx].fill}}></span>
                              í´ëŸ¬ìŠ¤í„° {idx + 1}:
                            </span>
                            <span className="font-bold" style={{color: clusterColors[idx].fill}}>{count}ê°œ</span>
                          </div>
                        ))}
                      </>
                    )}
                  </div>
                </div>
              </div>

              <div className="lg:col-span-3 space-y-4">
                <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
                  <h3 className="font-bold text-gray-900 mb-3 flex items-center gap-2">
                    <span className="text-xl">ğŸ¯</span>
                    <span>
                      {isSelectingCentroids 
                        ? `ì¤‘ì‹¬ì  ì„ íƒ ì¤‘... (${manualCentroids.length}/${numClusters})`
                        : '2ì°¨ì› íŠ¹ì„± ê³µê°„ (í´ë¦­í•˜ì—¬ ë°ì´í„° ì¶”ê°€)'}
                    </span>
                  </h3>
                  <div className="relative bg-white rounded-lg shadow-inner overflow-hidden border-2 border-gray-300">
                    <canvas 
                      ref={canvasRef} 
                      width={WIDTH} 
                      height={HEIGHT} 
                      onClick={handleClick}
                      className="block w-full cursor-crosshair" 
                    />
                  </div>

                  {converged && (
                    <div className="mt-4 bg-gradient-to-r from-green-50 to-emerald-50 p-5 rounded-lg border-2 border-green-400">
                      <h3 className="text-xl font-bold text-green-800 mb-3 flex items-center gap-2">
                        <span className="text-xl" onClick={handleCheckClick} style={{cursor:'pointer'}}>âœ…</span>
                        <span>í´ëŸ¬ìŠ¤í„°ë§ ì™„ë£Œ!</span>
                      </h3>
                      <div className="space-y-3">
                        <div className="bg-white p-4 rounded-lg shadow-sm">
                          <p className="font-semibold text-gray-800 mb-2">
                            ğŸŒŸ í´ëŸ¬ìŠ¤í„°ë§ ì •ë³´
                          </p>
                          <div className="space-y-2 text-sm text-gray-700">
                            <p>â€¢ <span className="font-semibold text-yellow-600">â­ ë…¸ë€ ë³„</span>: ê° í´ëŸ¬ìŠ¤í„°ì˜ ì¤‘ì‹¬ì </p>
                            <p>â€¢ <span className="font-semibold">ìƒ‰ìƒë³„ ì˜ì—­</span>: ê° í´ëŸ¬ìŠ¤í„°ì— ì†í•˜ëŠ” êµ¬ì—­</p>
                            <p>â€¢ ì´ <span className="font-bold text-purple-600">{iteration}ë²ˆì˜ ë°˜ë³µ</span>ìœ¼ë¡œ ìµœì ì˜ ê·¸ë£¹ì„ ì°¾ì•˜ì–´ìš”!</p>
                            <p>â€¢ <span className="font-bold text-green-600">{numClusters}ê°œì˜ í´ëŸ¬ìŠ¤í„°</span>ë¡œ ë°ì´í„°ë¥¼ ë‚˜ëˆ´ì–´ìš”</p>
                            <p>â€¢ <span className="font-bold text-blue-600">{initMethod === 'kmeans++' ? 'KMeans++' : 'Random'}</span> ì´ˆê¸°í™” ë°©ë²•ì„ ì‚¬ìš©í–ˆì–´ìš”</p>
                          </div>
                        </div>

                        <div className="bg-indigo-50 p-4 rounded-lg">
                          <p className="text-sm font-semibold text-indigo-900 mb-2">ğŸ’¡ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?</p>
                          <p className="text-sm text-gray-700 leading-relaxed">
                            k-MeansëŠ” <span className="font-bold text-blue-600">ê°€ì¥ ê°€ê¹Œìš´ ì¤‘ì‹¬ì </span>ì„ ì°¾ì•„ê°€ëŠ” ë°©ì‹ì´ì—ìš”. 
                            â‘  ëœë¤í•˜ê²Œ ì¤‘ì‹¬ì ì„ ì •í•˜ê³  â†’ â‘¡ ê° ë°ì´í„°ë¥¼ ê°€ì¥ ê°€ê¹Œìš´ ì¤‘ì‹¬ìœ¼ë¡œ ë°°ì •í•˜ê³  â†’ 
                            â‘¢ ê° ê·¸ë£¹ì˜ í‰ê·  ìœ„ì¹˜ë¥¼ ìƒˆë¡œìš´ ì¤‘ì‹¬ìœ¼ë¡œ ì •í•´ìš”. 
                            ì´ ê³¼ì •ì„ <span className="font-bold text-green-600">ì¤‘ì‹¬ì ì´ ë” ì´ìƒ ì•ˆ ì›€ì§ì¼ ë•Œê¹Œì§€</span> ë°˜ë³µí•©ë‹ˆë‹¤!
                          </p>
                        </div>
                      </div>
                    </div>
                  )}
                </div>

                <div className="flex justify-center gap-6 p-4 bg-gray-50 rounded-lg border border-gray-200">
                  <div className="flex items-center gap-2">
                    <div className="w-5 h-5 bg-gray-400 rounded-full border-2 border-gray-600"></div>
                    <span className="font-medium text-gray-700">ë¯¸ë¶„ë¥˜ ë°ì´í„°</span>
                  </div>
                  {clusterColors.slice(0, numClusters).map((color, idx) => (
                    <div key={idx} className="flex items-center gap-2">
                      <div className="w-5 h-5 rounded-full border-2 border-gray-800" style={{backgroundColor: color.fill}}></div>
                      <span className="font-medium text-gray-700">í´ëŸ¬ìŠ¤í„° {idx + 1}</span>
                    </div>
                  ))}
                  <div className="flex items-center gap-2">
                    <div className="text-yellow-500 text-xl">â­</div>
                    <span className="font-medium text-gray-700">ì¤‘ì‹¬ì </span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<KMeansDemo />);
  </script>
</body>
</html>